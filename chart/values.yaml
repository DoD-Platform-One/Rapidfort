secret:
  aws_access_key_id: ""
  aws_secret_access_key: ""
  aws_default_region: ""
  s3_bucket: ""

  # -- This value must be a syntax valid email (doesn't need to be a real one, though it should be for production)
  aws_access_key_id: FAKEID54G8A4F654GH7T
  aws_secret_access_key: FAKEKEYxlLONi5IEMW8zA0Va4l0i9yPwfD5AMn0K
  rf_app_admin: "rfadmin@fakeemail.com"
  rf_app_admin_passwd: "p@ssw0rd"
  # -- This field is used to provide the rapidfort service FQDN (if FQDN is not available use IP ADDRESS) to internal service
  rf_app_host: ""
  storage_type: "s3"

global:
  # -- This field is used to update the host name in the ingress.
  rf_app_host: ""
  allowed_rf_host: "api.rapidfort.com"

# -- When internal runner traffic is enabled runner defaults to `backend` for it's url
# if the backend service name is changed, update it here
runner_rf_app_host: ""

sharedPvcs:
  image-db-shared:
    storageSize: 10Gi
  imgs-work-dir-shared:
    storageSize: 10Gi
  local-bucket:
    storageSize: 10Gi

sc:
  enabled: false

aggregator:
  enabled: true
  image:
    repository: "registry1.dso.mil/ironbank/rapidfort/aggregator-exe"
    tag: "1.1.24-rfhardened"
  initContainers:
    volumePermissions:
      image:
        repository: "registry1.dso.mil/ironbank/redhat/ubi/ubi8-minimal"
        tag: "8.6"
  imagePullSecrets:
  - name: private-registry
  env:
    redis_host: redis-master
  PVCs:
    aggregatorRaidVolume:
      storageSize: 3Gi
  volumes:
  - name: raid-volume
    persistentVolumeClaim:
      claimName: aggregator-raid-volume
  - name: local-bucket
    persistentVolumeClaim:
      claimName: local-bucket
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: 'app.kubernetes.io/name'
            operator: In
            values:
            - iso-master
        topologyKey: "kubernetes.io/hostname"

backend:
  enabled: true
  community_service: 
    enabled: false
  image:
    repository: "registry1.dso.mil/ironbank/rapidfort/backend-exe"
    tag: "1.1.24-rfhardened"
  initContainers:
    enabled: true # this enables to add init container to keep waiting for dependent service to start
    init:
      image:
        repository: "registry1.dso.mil/ironbank/big-bang/base"
        tag: "2.0.0"
  imagePullSecrets:
  - name: private-registry
  env:
    redis_host: redis-master
  ingress:
    enabled: false
  PVCs:
    backendImgsWorkDir:
      storageSize: 10Gi
  volumes:
  - name: local-bucket
    persistentVolumeClaim:
      claimName: local-bucket
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: 'app.kubernetes.io/name'
            operator: In
            values:
            - iso-master
        topologyKey: "kubernetes.io/hostname"

frontrow:
  enabled: true
  authUrl: ""
  image:
    repository: "registry1.dso.mil/ironbank/rapidfort/frontrow"
    tag: "1.1.24-rfhardened"
  imagePullSecrets:
  - name: private-registry
  ingress:
    enabled: false

iso-master:
  enabled: true
  image:
    repository: "registry1.dso.mil/ironbank/rapidfort/iso-master-exe"
    tag: "1.1.24-rfhardened"
  initContainers:
    init:
      image:
        repository: "registry1.dso.mil/ironbank/big-bang/base"
        tag: "2.0.0"    
  imagePullSecrets:
  - name: private-registry
  env:
    redis_host: redis-master
    redis_host_ha: redis-master
  ingress:
    enabled: false
  # PVCs:
  #   iso-masterImgsWorkDir:
  #     storageSize: 10Gi
  #   iso-masterImageDb:
  #     storageSize: 10Gi
  volumes:
  - name: imgs-work-dir
    persistentVolumeClaim:
      claimName: imgs-work-dir-shared
  - name: image-db
    persistentVolumeClaim:
      claimName: image-db-shared
  - name: local-bucket
    persistentVolumeClaim:
      claimName: local-bucket

keycloak:
  enabled: true
  image:
    repository: "registry1.dso.mil/ironbank/rapidfort/keycloak"
    tag: 18.0.0-legacy
  initContainers:
    init_mysql:
      enabled: true
      image:
        repository: "registry1.dso.mil/ironbank/opensource/mysql/mysql8"
        tag: "8.0.31"
  imagePullSecrets:
  - name: private-registry
  ingress:
    enabled: false

mysql:
  # -- Set 'enabled' to true if you want to deploy a local (in-cluster) mysql instance
  enabled: true
  # To use an external mysql instance, set enabled to false and uncomment
  # the line below:
  # mysqlServer: ""

  # -- Seeding database required on intial run. Set to false if conducting a new install with existing data.
  # Ensure this is also set in the keycloak db.addr value
  seedDatabase: true

  # To use an external secret for the password for an external mysql
  # instance, set enabled to false and provide the name of the secret on the
  # line below:
  # existingSecret: ""
  # existingSecretPasswordKey: "mysql-password"

  initdbScriptsConfigMap: "init-db-configuration"
  fullnameOverride: "mysql"

  auth:
    ## @param auth.rootPassword Password for the `root` user. Ignored if existing secret is provided
    ## ref: https://github.com/bitnami/bitnami-docker-mysql#setting-the-root-password-on-first-run
    ##
    rootPassword: "mysql"
    ## @param auth.database Name for a custom database to create
    ## ref: https://github.com/bitnami/bitnami-docker-mysql/blob/master/README.md#creating-a-database-on-first-run
    ##
    database: standalone
    ## @param auth.username Name for a custom user to create
    ## ref: https://github.com/bitnami/bitnami-docker-mysql/blob/master/README.md#creating-a-database-user-on-first-run
    ##
    username: "mysql"
    ## @param auth.password Password for the new user. Ignored if existing secret is provided
    ##
    password: "mysql"
    ## @param auth.existingSecret Use existing secret for password details. The secret has to contain the keys `mysql-root-password`, `mysql-replication-password` and `mysql-password`
    ## NOTE: When it's set the auth.rootPassword, auth.password, auth.replicationPassword are ignored.
    ##
    existingSecret: ""

redis:
  enabled: true
  image:
    registry: registry1.dso.mil
    repository: ironbank/bitnami/redis
    tag: 7.0.5
  istio:
    enabled: false
  architecture: standalone
  fullnameOverride: "redis"
  auth:
    enabled: false
  # -- When enabled adds an extra service for redis to workaround an rfapi bug
  svcWorkaround: true

rf-scan:
  enabled: true
  image:
    repository: "registry1.dso.mil/ironbank/rapidfort/rf-scan-exe"
    tag: "1.1.24-rfhardened"
  initContainers:
    volumePermissions:
      image:
        repository: "registry1.dso.mil/ironbank/redhat/ubi/ubi8-minimal"
        tag: "8.6"
    init:
      image:
        repository: "registry1.dso.mil/ironbank/redhat/ubi/ubi8-minimal"
        tag: "8.6"        
  imagePullSecrets:
  - name: private-registry
  env:
    redis_host: redis-master
    redis_host_ha: redis-master
  ingress:
    enabled: false
  PVCs:
    rf-scanImgsWorkDir:
      storageSize: 10Gi
    rf-scanImageDb:
      storageSize: 10Gi
  # TODO: confirm the volumes and update references.      
  volumes:
  - name: local-bucket
    persistentVolumeClaim:
      claimName: local-bucket
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: 'app.kubernetes.io/name'
            operator: In
            values:
            - iso-master
        topologyKey: "kubernetes.io/hostname"

rfapi:
  enabled: true
  image:
    repository: "registry1.dso.mil/ironbank/rapidfort/rfapi-exe"
    tag: "1.1.24-rfhardened"
  initContainers:
    enabled: true # this enables to add init container to keep waiting for dependent service to start
    init:
      image:
        repository: "registry1.dso.mil/ironbank/bitnami/redis"
        tag: "7.0.5"
  imagePullSecrets:
  - name: private-registry
  env:
    redis_host: redis-master
  ingress:
    websocket:
      enabled: false
    http:
      enabled: false

rfpubsub:
  enabled: true
  image:
    repository: "registry1.dso.mil/ironbank/rapidfort/rfpubsub-exe"
    tag: "1.1.24-rfhardened"
  imagePullSecrets:
  - name: private-registry
  env:
    redis_host: redis-master
    redis_host_ha: redis-master
  ingress:
    enabled: false

runner:
  enabled: true
  secret:
    # -- Change to rf-runner-secret to internalize runner traffic
    name: rf-secret
  image:
    repository: "registry1.dso.mil/ironbank/rapidfort/runner"
    tag: "1.1.24-rfhardened"
  initContainers:
    init:
      enabled: true # this enables to add init container to keep waiting for dependent service to start
      image:
        repository: "registry1.dso.mil/ironbank/big-bang/base"
        tag: "2.0.0"
  imagePullSecrets:
  - name: private-registry
  env:
    redis_host: redis-master
    redis_host_ha: redis-master
  ingress:
    enabled: false

vulns-db:
  enabled: true
  image:
    repository: "registry1.dso.mil/ironbank/rapidfort/vulns-db"
    tag: "1.1.24-rfhardened"
  env:
    rfvdb_host: "api.rapidfort.com"
    redis_host: redis-master
    redis_host_ha: redis-master    
  ingress:
    enabled: false
  imagePullSecrets:
  - name: private-registry

logger:
  enabled: false

# -- Big Bang Values
domain: bigbang.dev
istio:
  enabled: false
  mtls:
    # -- STRICT = Allow only mutual TLS traffic,
    # PERMISSIVE = Allow both plain text and mutual TLS traffic
    # PERMISSIVE is required for any action which redeploys pods because STRICT interferes with initContainers
    # Can be changed to STRICT after all initContainers have finished but will interfere with upgrades/pod deployments that have initContainers
    mode: PERMISSIVE
  rapidfort:
    enabled: false
    gateways:
    - istio-system/public
    hosts:
    - rapidfort.{{ .Values.domain }}

networkPolicies:
  enabled: false
  ingressLabels: 
    app: istio-ingressgateway
    istio: ingressgateway
  # -- IP range of api.rapidfort.com
  rapidfortApiIpRange: ""
  # -- test
  controlPlaneCidr: ""

# -- Bigbang helm test values - default disabled
bbtests:
  enabled: false
  cypress:
    artifacts: true
    envs:
      # dummy values for now
      # cypress_url: 'http://{{ template "rapidfort.fullname" . }}.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.frontrow.service.port }}'
      cypress_url: 'http://test.test'
  scripts:
    envs:
      URL: 'http://test.test'
      # URL: 'http://{{ template "rapidfort.fullname" . }}.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.frontrow.service.port }}'
